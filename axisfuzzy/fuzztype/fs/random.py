#  Copyright (c) yibocat 2025 All Rights Reserved
#  Python: 3.12.7
#  Date: 2025/8/18 18:23
#  Author: yibow
#  Email: yibocat@yeah.net
#  Software: AxisFuzzy

"""
Fuzzy Sets (FS) Random Generator Implementation.

This module implements the random generator for classical fuzzy sets (FS),
providing efficient generation of random fuzzy numbers with only membership
degrees based on Zadeh's fuzzy set theory.

The FSRandomGenerator class provides:
- Simple membership degree generation (md ∈ [0, 1])
- Support for multiple probability distributions
- High-performance vectorized batch generation
- Optimal integration with AxisFuzzy's random generation framework

Mathematical Foundation:
    A random fuzzy set A is generated by sampling membership degrees from
    a specified probability distribution:
    
    A = {⟨x, μ_A(x)⟩ | μ_A(x) ~ D(θ), x ∈ X}
    
    where D(θ) is a probability distribution with parameters θ, and
    μ_A(x) ∈ [0, 1] for all x.

Supported Distributions:
    - uniform: Uniform distribution over [low, high]
    - beta: Beta distribution with shape parameters a, b
    - normal: Normal distribution (clipped to [0, 1])

Examples:
    .. code-block:: python

        import axisfuzzy.random as fr
        
        # Generate single FS fuzzy number
        fs_num = fr.rand('fs')
        print(fs_num)  # <0.7354> (random value)
        
        # Generate array with beta distribution
        fs_array = fr.rand('fs', 
                          shape=(100,), 
                          md_dist='beta', 
                          a=2.0, b=5.0)
        print(fs_array.shape)  # (100,)
        
        # Generate with custom range
        custom_fs = fr.rand('fs', 
                           shape=(50,), 
                           md_low=0.2, 
                           md_high=0.8)
"""

from typing import Dict, Any, Tuple, Optional
import numpy as np

from axisfuzzy.core import Fuzznum, Fuzzarray
from axisfuzzy.random.base import ParameterizedRandomGenerator
from axisfuzzy.random.registry import register_random

from .backend import FSBackend


@register_random
class FSRandomGenerator(ParameterizedRandomGenerator):
    """
    Random generator for classical Fuzzy Sets (FS).
    
    This generator creates random FS fuzzy numbers by sampling membership degrees
    from various probability distributions. It supports both single instance
    generation and high-performance batch generation with vectorized operations.
    
    Attributes:
        mtype (str): Membership type identifier, set to 'fs'
    
    Mathematical Properties:
        - Single component: membership degree md ∈ [0, 1]
        - No mathematical constraints beyond range validation
        - Represents classical Zadeh fuzzy sets
        - Optimal for basic fuzzy logic applications
    
    Performance Characteristics:
        - Minimal computational overhead (single component generation)
        - Maximum vectorization efficiency for batch operations
        - Direct backend construction for optimal memory usage
        - Support for all framework distribution utilities
    
    Parameter Categories:
        1. Distribution Control: md_dist, md_low, md_high
        2. Beta Distribution: a, b (shape parameters)
        3. Normal Distribution: loc, scale (location and scale)
    
    Examples:
        .. code-block:: python
        
            # Basic uniform generation
            generator = FSRandomGenerator()
            rng = np.random.default_rng(42)
            
            # Single fuzzy number
            fs_num = generator.fuzznum(rng)
            print(fs_num.md)  # Random value in [0, 1]
            
            # Batch generation with beta distribution
            params = {'md_dist': 'beta', 'a': 2.0, 'b': 5.0}
            fs_array = generator.fuzzarray(rng, (1000,), **params)
            print(fs_array.shape)  # (1000,)
    """
    
    # Type identifier for registration system
    mtype = "fs"

    def get_default_parameters(self) -> Dict[str, Any]:
        """
        Define default parameter set for FS generation.
        
        Returns comprehensive parameter configuration with sensible defaults
        for membership degree generation using various probability distributions.
        
        Returns:
            Dict[str, Any]: Default parameters for FS random generation
        
        Parameter Descriptions:
            - md_dist: Distribution type for membership degrees
            - md_low, md_high: Range bounds for membership degrees
            - a, b: Shape parameters for beta distribution
            - loc, scale: Parameters for normal distribution
        """
        return {
            # Membership degree distribution parameters
            'md_dist': 'uniform',    # Distribution type: 'uniform', 'beta', 'normal'
            'md_low': 0.0,           # Lower bound for membership degrees
            'md_high': 1.0,          # Upper bound for membership degrees
            
            # Beta distribution shape parameters
            'a': 2.0,                # Alpha parameter (shape)
            'b': 2.0,                # Beta parameter (shape)
            
            # Normal distribution parameters
            'loc': 0.5,              # Mean (location parameter)
            'scale': 0.15,           # Standard deviation (scale parameter)
        }

    def validate_parameters(self, **params) -> None:
        """
        Validate parameter values for FS generation.
        
        Performs comprehensive validation to ensure mathematical consistency
        and prevent invalid generation configurations that could produce
        malformed FS instances.
        
        Parameters:
            **params: Generation parameters to validate
        
        Raises:
            ValueError: If parameters violate FS constraints or mathematical requirements
            TypeError: If parameter types are incorrect
        
        Validation Checks:
            1. Range validation for membership bounds
            2. Cross-parameter consistency (md_low < md_high)
            3. Distribution-specific parameter validation
            4. Type checking for numerical parameters
        """
        # Merge with defaults for complete parameter set
        params = self._merge_parameters(**params)
        
        # Range validation for membership degree bounds
        self._validate_range('md_low', params['md_low'], 0.0, 1.0)
        self._validate_range('md_high', params['md_high'], 0.0, 1.0)
        
        # Cross-parameter consistency validation
        if params['md_low'] >= params['md_high']:
            raise ValueError(f"md_low ({params['md_low']}) must be less than "
                           f"md_high ({params['md_high']})")
        
        # Distribution-specific parameter validation
        if params['md_dist'] == 'beta':
            if params['a'] <= 0 or params['b'] <= 0:
                raise ValueError(f"Beta distribution requires positive shape parameters: "
                               f"a={params['a']}, b={params['b']}")
        
        elif params['md_dist'] == 'normal':
            if params['scale'] <= 0:
                raise ValueError(f"Normal distribution requires positive scale parameter: "
                               f"scale={params['scale']}")
        
        elif params['md_dist'] not in ['uniform', 'beta', 'normal']:
            raise ValueError(f"Unsupported distribution type: {params['md_dist']}. "
                           f"Supported types: 'uniform', 'beta', 'normal'")
        
        # Type validation for numerical parameters
        numerical_params = ['md_low', 'md_high', 'a', 'b', 'loc', 'scale']
        for param_name in numerical_params:
            if param_name in params:
                param_value = params[param_name]
                if not isinstance(param_value, (int, float, np.floating, np.integer)):
                    raise TypeError(f"Parameter '{param_name}' must be numerical, "
                                  f"got {type(param_value)}")

    def fuzznum(self, rng: np.random.Generator, **params) -> 'Fuzznum':
        """
        Generate a single FS fuzzy number.
        
        Creates an individual FS instance by sampling a membership degree
        from the specified probability distribution and constructing a
        Fuzznum object with proper validation.
        
        Parameters:
            rng (np.random.Generator): Random number generator instance
            **params: Generation parameters (merged with defaults)
        
        Returns:
            Fuzznum: Single FS fuzzy number instance
        
        Mathematical Process:
            1. Sample membership degree: md ~ D(θ)
            2. Apply range constraints: md ∈ [md_low, md_high]
            3. Create Fuzznum: FS = ⟨md⟩
        
        Examples:
            .. code-block:: python
            
                rng = np.random.default_rng(42)
                
                # Uniform distribution (default)
                fs1 = generator.fuzznum(rng)
                
                # Beta distribution with custom parameters
                fs2 = generator.fuzznum(rng, md_dist='beta', a=3.0, b=2.0)
                
                # Normal distribution with clipping
                fs3 = generator.fuzznum(rng, md_dist='normal', loc=0.7, scale=0.1)
        """
        # Merge and validate parameters
        params = self._merge_parameters(**params)
        self.validate_parameters(**params)
        
        # Sample membership degree using distribution utility
        md = self._sample_from_distribution(
            rng, 
            size=None, 
            dist=params['md_dist'],
            low=params['md_low'], 
            high=params['md_high'],
            a=params['a'], 
            b=params['b'],
            loc=params['loc'], 
            scale=params['scale']
        )
        
        # Ensure membership degree is scalar and in valid range
        md = float(np.clip(md, 0.0, 1.0))
        
        # Create and return Fuzznum instance
        return Fuzznum(mtype=self.mtype).create(md=md)

    def fuzzarray(self, rng: np.random.Generator, 
                  shape: Tuple[int, ...], **params) -> 'Fuzzarray':
        """
        Generate a batch of FS fuzzy numbers using high-performance vectorized operations.
        
        Creates a Fuzzarray of the specified shape by performing vectorized
        sampling and direct backend construction for optimal performance.
        
        Parameters:
            rng (np.random.Generator): Random number generator instance
            shape (Tuple[int, ...]): Desired shape of the output array
            **params: Generation parameters (merged with defaults)
        
        Returns:
            Fuzzarray: High-performance FS fuzzy array
        
        Performance Optimizations:
            1. Vectorized sampling for all elements simultaneously
            2. Direct backend construction without intermediate objects
            3. Efficient memory layout using SoA architecture
            4. NumPy-level operations for maximum speed
        
        Examples:
            .. code-block:: python
            
                rng = np.random.default_rng(123)
                
                # Large-scale uniform generation
                large_array = generator.fuzzarray(rng, (10000,))
                
                # 2D array with beta distribution
                matrix = generator.fuzzarray(rng, (100, 50), 
                                           md_dist='beta', a=1.5, b=3.0)
                
                # Custom range generation
                custom_array = generator.fuzzarray(rng, (500,),
                                                 md_low=0.3, md_high=0.7)
        """
        # Merge and validate parameters
        params = self._merge_parameters(**params)
        self.validate_parameters(**params)
        
        # Calculate total number of elements for vectorized sampling
        size = int(np.prod(shape))
        
        # Vectorized membership degree generation
        mds = self._sample_from_distribution(
            rng, size=size, dist=params['md_dist'],
            low=params['md_low'], high=params['md_high'],
            a=params['a'], b=params['b'],
            loc=params['loc'], scale=params['scale']
        )
        
        # Apply range constraints and reshape to target shape
        mds = np.clip(mds, 0.0, 1.0).reshape(shape)
        
        # Create backend directly from arrays for maximum performance
        backend = FSBackend.from_arrays(mds=mds)
        
        # Wrap backend in Fuzzarray with type metadata
        return Fuzzarray(backend=backend, mtype=self.mtype)