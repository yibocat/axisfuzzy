#  Copyright (c) yibocat 2025 All Rights Reserved
#  Python: 3.12.7
#  Date: 2025/8/18 18:23
#  Author: yibow
#  Email: yibocat@yeah.net
#  Software: AxisFuzzy

from typing import Any, Dict, Union, Optional, Tuple, List, Literal
import numpy as np

from ..core import Fuzznum, Fuzzarray


# Re-export the public decorators from the decorator submodule.
# Their full signatures are defined in `decorator.pyi`.
from .decorator import extension as extension
from .decorator import batch_extension as batch_extension

# --- Top-Level Extension Function Signatures ---
# This file serves as the static "API Contract" for all functions that can be
# injected into the top-level namespace by the extension system.
# The actual implementation is provided by specific mtypes at runtime.

# Constructor functions
def empty(*args: Any, **kwargs: Any) -> Union[Fuzzarray, Fuzznum]: ...
def positive(*args: Any, **kwargs: Any) -> Union[Fuzzarray, Fuzznum]: ...
def negative(*args: Any, **kwargs: Any) -> Union[Fuzzarray, Fuzznum]: ...
def full(*args: Any, **kwargs: Any) -> Union[Fuzzarray, Fuzznum]: ...
def empty_like(*args: Any, **kwargs: Any) -> Union[Fuzzarray, Fuzznum]: ...
def positive_like(*args: Any, **kwargs: Any) -> Union[Fuzzarray, Fuzznum]: ...
def negative_like(*args: Any, **kwargs: Any) -> Union[Fuzzarray, Fuzznum]: ...
def full_like(*args: Any, **kwargs: Any) -> Union[Fuzzarray, Fuzznum]: ...

# IO functions
def read_csv(*args: Any, **kwargs: Any) -> Fuzzarray: ...
def read_json(*args: Any, **kwargs: Any) -> Fuzzarray: ...
def read_npy(*args: Any, **kwargs: Any) -> Fuzzarray: ...

# Measurement functions
def distance(fuzz_1: Union[Fuzznum, Fuzzarray], fuzz_2: Union[Fuzznum, Fuzzarray], *args: Any, **kwargs: Any) -> Union[np.ndarray, float]: ...

def normalize(f1: Fuzznum, f2: Fuzznum, tao: float = ...) -> Tuple[Fuzznum, Fuzznum]: ...

# String conversion functions
def str2fuzznum(fuzznum_str: str, *args: Any, **kwargs: Any) -> Fuzznum: ...

# Aggregation functions
def sum(fuzz: Union[Fuzzarray, Fuzznum], axis: Optional[int] = ..., **kwargs: Any) -> Union[Fuzzarray, Fuzznum]: ...
def mean(fuzz: Union[Fuzzarray, Fuzznum], axis: Optional[int] = ..., **kwargs: Any) -> Union[Fuzzarray, Fuzznum]: ...
def max(fuzz: Union[Fuzzarray, Fuzznum], axis: Optional[int] = ..., **kwargs: Any) -> Union[Fuzzarray, Fuzznum]: ...
def min(fuzz: Union[Fuzzarray, Fuzznum], axis: Optional[int] = ..., **kwargs: Any) -> Union[Fuzzarray, Fuzznum]: ...
def prod(fuzz: Union[Fuzzarray, Fuzznum], axis: Optional[int] = ..., **kwargs: Any) -> Union[Fuzzarray, Fuzznum]: ...
def var(fuzz: Union[Fuzzarray, Fuzznum], axis: Optional[int] = ..., **kwargs: Any) -> Union[Fuzzarray, Fuzznum]: ...
def std(fuzz: Union[Fuzzarray, Fuzznum], axis: Optional[int] = ..., **kwargs: Any) -> Union[Fuzzarray, Fuzznum]: ...

# --- System Functions & Classes ---
from .registry import ExtensionRegistry
from .dispatcher import ExtensionDispatcher
from .injector import ExtensionInjector

def get_registry_extension() -> ExtensionRegistry: ...
def get_extension_dispatcher() -> ExtensionDispatcher: ...
def get_extension_injector() -> ExtensionInjector: ...
def apply_extensions(force_reapply: bool = ...) -> bool: ...

def external_extension(
    name: str,
    mtype: Optional[str] = ...,
    target_classes: Union[str, List[str], None] = ...,
    injection_type: Literal[
        'instance_method',
        'instance_property', 
        'top_level_function',
        'both'
    ] = ...,
    is_default: bool = ...,
    priority: int = ...,
    auto_apply: bool = ...,
    **kwargs: Any
) -> Any: ...
