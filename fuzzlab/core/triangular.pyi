#  Copyright (c) yibocat 2025 All Rights Reserved
#  Python: 3.10.9
#  Date: 2025/8/15 11:43
#  Author: yibow
#  Email: yibocat@yeah.net
#  Software: FuzzLab
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional, Union, Tuple, Callable, List

import numpy as np


class TypeNormalizer:
    @staticmethod
    def to_float(value: Any) -> float: ...

    @staticmethod
    def to_int(value: Any) -> int: ...

    @staticmethod
    def ensure_array_output(value: Any) -> np.ndarray: ...

    @staticmethod
    def ensure_scalar_output(value: Any) -> float: ...

class BaseNormOperation(ABC):
    q: int
    params: Dict[str, Any]
    is_archimedean: bool
    is_strict_archimedean: bool
    supports_q: bool

    def __init__(self, q: int = ..., **params: Any) -> None: ...

    @abstractmethod
    def t_norm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...

    @abstractmethod
    def t_conorm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...

    def g_func_impl(self, a: np.ndarray) -> Optional[np.ndarray]: ...

    def g_inv_func_impl(self, u: np.ndarray) -> Optional[np.ndarray]: ...

class AlgebraicNorm(BaseNormOperation):
    def __init__(self, q: int = ..., **params: Any) -> None: ...
    def t_norm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def t_conorm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def g_func_impl(self, a: np.ndarray) -> np.ndarray: ...
    def g_inv_func_impl(self, u: np.ndarray) -> np.ndarray: ...

class LukasiewiczNorm(BaseNormOperation):
    def __init__(self, q: int = ..., **params: Any) -> None: ...
    def t_norm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def t_conorm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def g_func_impl(self, a: np.ndarray) -> np.ndarray: ...
    def g_inv_func_impl(self, u: np.ndarray) -> np.ndarray: ...

class EinsteinNorm(BaseNormOperation):
    def __init__(self, q: int = ..., **params: Any) -> None: ...
    def t_norm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def t_conorm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def g_func_impl(self, a: np.ndarray) -> np.ndarray: ...
    def g_inv_func_impl(self, u: np.ndarray) -> np.ndarray: ...

class HamacherNorm(BaseNormOperation):
    gamma: float

    def __init__(self, q: int = ..., **params: Any) -> None: ...
    def t_norm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def t_conorm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def g_func_impl(self, a: np.ndarray) -> np.ndarray: ...
    def g_inv_func_impl(self, u: np.ndarray) -> np.ndarray: ...

class YagerNorm(BaseNormOperation):
    p: float

    def __init__(self, q: int = ..., **params: Any) -> None: ...
    def t_norm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def t_conorm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def g_func_impl(self, a: np.ndarray) -> np.ndarray: ...
    def g_inv_func_impl(self, u: np.ndarray) -> np.ndarray: ...

class SchweizerSklarNorm(BaseNormOperation):
    p: float

    def __init__(self, q: int = ..., **params: Any) -> None: ...
    def t_norm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def t_conorm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def g_func_impl(self, a: np.ndarray) -> np.ndarray: ...
    def g_inv_func_impl(self, u: np.ndarray) -> np.ndarray: ...

class DombiNorm(BaseNormOperation):
    p: float

    def __init__(self, q: int = ..., **params: Any) -> None: ...
    def t_norm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def t_conorm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def g_func_impl(self, a: np.ndarray) -> np.ndarray: ...
    def g_inv_func_impl(self, u: np.ndarray) -> np.ndarray: ...

class AczelAlsinaNorm(BaseNormOperation):
    p: float

    def __init__(self, q: int = ..., **params: Any) -> None: ...
    def t_norm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def t_conorm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def g_func_impl(self, a: np.ndarray) -> np.ndarray: ...
    def g_inv_func_impl(self, u: np.ndarray) -> np.ndarray: ...

class FrankNorm(BaseNormOperation):
    s: float
    _S_INF_THRESHOLD: float

    def __init__(self, q: int = ..., **params: Any) -> None: ...
    def t_norm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def t_conorm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def g_func_impl(self, a: np.ndarray) -> np.ndarray: ...
    def g_inv_func_impl(self, u: np.ndarray) -> np.ndarray: ...

class MinimumNorm(BaseNormOperation):
    def __init__(self, q: int = ..., **params: Any) -> None: ...
    def t_norm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def t_conorm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...

class DrasticNorm(BaseNormOperation):
    def __init__(self, q: int = ..., **params: Any) -> None: ...
    def t_norm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def t_conorm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...

class NilpotentNorm(BaseNormOperation):
    def __init__(self, q: int = ..., **params: Any) -> None: ...
    def t_norm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
    def t_conorm_impl(self, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...

class OperationTNorm:
    _NORM_REGISTRY: Dict[str, type]

    norm_type: str
    q: int
    params: Dict[str, Any]
    is_archimedean: bool
    is_strict_archimedean: bool
    supports_q: bool
    _norm_op: BaseNormOperation

    # 操作函数
    t_norm: Callable[[Any, Any], Union[float, np.ndarray]]
    t_conorm: Callable[[Any, Any], Union[float, np.ndarray]]
    g_func: Optional[Callable[[Any], Union[float, np.ndarray]]]
    g_inv_func: Optional[Callable[[Any], Union[float, np.ndarray]]]
    f_func: Optional[Callable[[Any], Union[float, np.ndarray]]]
    f_inv_func: Optional[Callable[[Any], Union[float, np.ndarray]]]

    def __init__(self,
                 norm_type: Optional[str] = ...,
                 q: int = ...,
                 **params: Any) -> None: ...

    def _initialize_functions(self) -> None: ...
    def _create_standard_t_norm(self) -> Callable: ...
    def _create_standard_t_conorm(self) -> Callable: ...
    def _create_q_extended_t_norm(self) -> Callable: ...
    def _create_q_extended_t_conorm(self) -> Callable: ...
    def _create_generator(self) -> Optional[Callable]: ...
    def _create_generator_inv(self) -> Optional[Callable]: ...
    def _create_dual_generator(self) -> Optional[Callable]: ...
    def _create_dual_generator_inv(self) -> Optional[Callable]: ...

    def _pairwise_reduce(self,
                        func: Callable[[np.ndarray, np.ndarray], np.ndarray],
                        arr: np.ndarray) -> np.ndarray: ...

    def _generic_reduce(self,
                       func: Callable[[np.ndarray, np.ndarray], np.ndarray],
                       array: np.ndarray,
                       axis: Optional[Union[int, Tuple[int, ...]]]) -> np.ndarray: ...

    def t_norm_reduce(self,
                     array: np.ndarray,
                     axis: Optional[Union[int, Tuple[int, ...]]] = ...) -> np.ndarray: ...

    def t_conorm_reduce(self,
                       array: np.ndarray,
                       axis: Optional[Union[int, Tuple[int, ...]]] = ...) -> np.ndarray: ...

    # 验证函数
    def _verify_properties(self) -> None: ...
    def _verify_t_norm_axioms(self) -> None: ...
    def _verify_archimedean_property(self) -> None: ...
    def _verify_generator_properties(self) -> None: ...

    def verify_de_morgan_laws(self, a: float = ..., b: float = ...) -> Dict[str, bool]: ...

    # 信息获取
    def get_info(self) -> Dict[str, Any]: ...
    def plot_t_norm_surface(self, resolution: int = ...) -> None: ...

    # 工具方法
    @staticmethod
    def register_norm(name: str, norm_class: type) -> None: ...

    @staticmethod
    def list_available_norms() -> List[str]: ...

    @classmethod
    def from_generator(cls,
                      g_func: Callable,
                      g_inv_func: Callable,
                      norm_type: str = ...,
                      q: int = ...,
                      **params: Any) -> OperationTNorm: ...

def create_tnorm(norm_type: str = ..., q: int = ..., **params: Any) -> OperationTNorm: ...

__all__: List[str]

