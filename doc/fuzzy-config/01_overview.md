# `axisfuzzy.config` 配置系统：概述

欢迎来到 `axisfuzzy` 的配置系统。在任何一个设计精良的库中，提供一套灵活、可控且易于使用的配置机制都至关重要。它允许用户根据自己的特定需求（如计算精度、显示样式、默认行为等）来定制库的行为，而无需修改库的源代码。

`axisfuzzy.config` 正是为此目标而设计的。它是一个结构清晰、线程安全且功能完备的系统，旨在为 `axisfuzzy` 的所有模块提供统一、集中化的配置管理能力。

## 1. 设计理念

`axisfuzzy.config` 的设计遵循以下四大核心理念：

- **集中化管理 (Centralized Management)**
  所有的配置项都集中定义在唯一的 `Config` 数据类中。这种设计使得配置项易于查找、理解和维护。开发者和用户都能在一个地方看到所有可用的配置选项。

- **简单易用 (Simplicity & Ease of Use)**
  系统对外暴露了一套极其简洁的顶层 API，如 `get_config()` 和 `set_config()`。用户无需了解底层复杂的 `ConfigManager`，即可轻松读取和修改配置。

- **类型安全与验证 (Type Safety & Validation)**
  每个配置项都附带了元数据，包括类型验证器和描述信息。在修改配置时，系统会自动进行验证，防止用户设置无效的值（例如，将精度设置为负数），从而保证了系统的稳定性和可靠性。

- **持久化与可移植性 (Persistence & Portability)**
  配置状态不仅可以在运行时动态修改，还可以方便地从 JSON 文件加载或保存到 JSON 文件。这使得用户可以在不同项目、不同环境中轻松复用和分享同一套配置。

## 2. 系统架构与核心组件

整个配置系统由四个核心文件组成，它们各司其职，共同构成了一个完整的配置管理闭环：

| 模块              | 作用                                                              |
| ----------------- | ----------------------------------------------------------------- |
| **`config_file.py`** | 定义 `Config` 数据类，作为所有配置项的“蓝图”和数据容器。             |
| **`manager.py`**    | 实现 `ConfigManager` 单例类，是配置系统的“引擎”，负责管理、验证和持久化。 |
| **`api.py`**        | 提供面向用户的全局便利函数，是与系统交互的“门面”。                      |
| **`__init__.py`**   | 将 `api.py` 中的函数和 `Config` 类导出到 `axisfuzzy.config` 命名空间。 |

系统架构图如下：

```text
┌─────────────────────────────────────────────────────────────────┐
│                        用户层 (User Layer)                        │
├─────────────────────────────────────────────────────────────────┤
│ af.config.get_config() │ af.config.set_config() │ af.config.load() │
└─────────────┬───────────────────────────────────────────────────┘
              │
┌─────────────▼───────────────────────────────────────────────────┐
│                       API 层 (api.py)                            │
│  • 提供全局便利函数                                                │
│  • 隐藏底层管理器实现                                              │
└─────────────┬───────────────────────────────────────────────────┘
              │
┌─────────────▼───────────────────────────────────────────────────┐
│                     管理器层 (manager.py)                         │
│  • ConfigManager (Singleton)                                    │
│  • 管理全局唯一的 Config 实例                                      │
│  • 实现验证、加载、保存逻辑                                        │
└─────────────┬───────────────────────────────────────────────────┘
              │
┌─────────────▼───────────────────────────────────────────────────┐
│                      数据模型层 (config_file.py)                  │
│  • Config (Dataclass)                                           │
│  • 定义所有配置项、默认值和元数据（验证器、描述等）                  │
└─────────────────────────────────────────────────────────────────┘
```

下面我们来逐一了解这几个核心组件：

- **1. 数据模型层 (`config_file.py`)**
    - **角色**：配置系统的“**数据结构定义**”。
    - **职责**：它定义了 `Config` 这个 `dataclass`，其中包含了所有全局配置项，例如 `DEFAULT_MTYPE`, `DEFAULT_PRECISION` 等。每个字段都通过 `field` 函数附加了元数据（`metadata`），用于描述其用途、类别和验证规则。

- **2. 管理器层 (`manager.py`)**
    - **角色**：配置系统的“**核心引擎**”。
    - **职责**：`ConfigManager` 是一个线程安全的单例类，它在内部维护着一个全局唯一的 `Config` 实例。所有对配置的修改、验证、加载（从文件）和保存（到文件）等复杂操作都由它统一处理。

- **3. API 层 (`api.py`)**
    - **角色**：用户与配置系统交互的“**高级接口**”。
    - **职责**：它提供了一系列简单直观的全局函数，如 `get_config()`, `set_config()`, `load_config_file()` 等。这些函数内部会调用 `ConfigManager` 的相应方法，从而将用户与复杂的管理器逻辑解耦。

## 3. 数据流：一次 `set_config` 调用的生命周期

为了更好地理解这些组件如何协同工作，让我们追踪一次典型的函数调用：

```python
import axisfuzzy.config as config

# 用户调用
config.set_config(DEFAULT_PRECISION=6, CACHE_SIZE=512)
```

**Step 1: API 层接收请求**
用户调用 `config.set_config()` 函数，传入希望修改的配置项及其新值。`api.py` 中的 `set_config` 函数接收到这些参数。

```text
api.set_config() 接收参数:
├─ DEFAULT_PRECISION=6
└─ CACHE_SIZE=512
```

**Step 2: API 层转发给管理器**
`api.py` 中的函数是一个简单的包装器，它会获取全局的 `ConfigManager` 实例，并调用其 `set_config` 方法，将参数原封不动地传递过去。

```text
_config_manager.set_config(DEFAULT_PRECISION=6, CACHE_SIZE=512)
```

**Step 3: 管理器进行验证和更新**
`ConfigManager` 接收到请求后，会遍历每一个传入的键值对（`key`, `value`）：
- **查找字段**：它会检查 `key` (如 `'DEFAULT_PRECISION'`) 是否是 `Config` dataclass 中定义的合法字段。
- **执行验证**：如果字段合法，它会从该字段的元数据中提取 `validator` 函数，并用它来验证 `value` (如 `6`) 的有效性。例如，验证 `DEFAULT_PRECISION` 必须是一个非负整数。
- **更新状态**：验证通过后，管理器会使用 `setattr` 更新其内部维护的 `Config` 实例的对应字段值。

```text
ConfigManager.set_config():
├─ For 'DEFAULT_PRECISION':
│  ├─ 验证: is_valid = validator(6) -> True
│  └─ 更新: self._config.DEFAULT_PRECISION = 6
├─ For 'CACHE_SIZE':
│  ├─ 验证: is_valid = validator(512) -> True
│  └─ 更新: self._config.CACHE_SIZE = 512
└─ 标记为已修改
```

**Step 4: 完成**
所有配置项更新完毕后，调用结束。全局配置状态已被安全、可靠地修改。后续 `axisfuzzy` 库中任何依赖这些配置项的功能都将立即使用新的值。

通过这个流程，`axisfuzzy.config` 在保证强大功能（如验证和持久化）的同时，为最终用户提供了极为简洁和安全的使用体验。